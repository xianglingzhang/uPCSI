
/** @file
 *****************************************************************************
 This is an implementation of multi-point OPRF.

 References:
 \[CM20]: 
 "Private Set Intersection in the Internet Setting From Lightweight",
 Melissa Chase, Peihan Miao,
 CRYPTO 2020,
 <https://eprint.iacr.org/2020/729>

 Modified from the following project:
 <https://github.com/peihanmiao/OPRF-PSI>

 With modifications:
 1. Support multi-thread programming with OpenMP (improve computation efficiency);
 2. Substitute the unordered_map with bloom filter to do membership test (reduce communication cost).

 *****************************************************************************
 * @author     developed by Xiangling Zhang
 * @copyright  MIT license (see LICENSE file)
 *****************************************************************************/

#ifndef KUNLUN_MPOPRF_HPP_
#define KUNLUN_MPOPRF_HPP_

#include "../ot/naor_pinkas_ot.hpp"

namespace MPOPRF{
    // the output length \ell1 in bytes of hash function H1
    const size_t H1_OUTPUT_LEN = 32;

    struct PP
    {
        size_t set_size; // n
        size_t matrix_height; // m (matrix_height = set_size)
        size_t log_matrix_height; // logm
        size_t matrix_width; // w
        size_t H2_OUTPUT_LEN; // the output length \ell2 in bytes of hash function H2, H2_OUTPUT_LEN < H1_OUTPUT_LEN
        size_t BATCH_SIZE; // the batch size dealing with the set_size loops, set_size % BATCH_SIZE = 0

        NPOT::PP npot_part;
        // a common PRG seed, used to generate a number of AES keys, PRG(commonseed) -> k0 || k1 || ... || kt
        PRG::Seed commonseed; 
    };
    
    PP Setup(size_t log_set_size, size_t sigma = 40)
    {
	    PP pp; 
	    pp.set_size = 1 << log_set_size;
        pp.matrix_height = pp.set_size;
        pp.log_matrix_height = log_set_size;
        pp.H2_OUTPUT_LEN = ((sigma + 2*log_set_size) + 7) >> 3; // the statistical security parameter is 40
        pp.BATCH_SIZE = 128;

        pp.npot_part = NPOT::Setup();
        // use the agreed PRF key to initiate a common PRG seed
        pp.commonseed = PRG::SetSeed(fix_key, 0); 

        // parameters of matrix width for input set size in page 16 table 1
        if (log_set_size <= 10) pp.matrix_width = 591;
        else if (log_set_size <= 12) pp.matrix_width = 597;
        else if (log_set_size <= 14) pp.matrix_width = 603;
        else if (log_set_size <= 16) pp.matrix_width = 609;
        else if (log_set_size <= 18) pp.matrix_width = 615;
        else if (log_set_size <= 20) pp.matrix_width = 621;
        else pp.matrix_width = 633;
        
	    return pp; 
    }

    // save pp to file
    void SavePP(PP &pp, std::string pp_filename)
    {
        std::ofstream fout; 
        fout.open(pp_filename, std::ios::binary); 
        if(!fout)
        {
            std::cerr << pp_filename << " open error" << std::endl;
            exit(1); 
        }

        fout << pp.set_size; 
        fout << pp.matrix_height; 
        fout << pp.log_matrix_height; 
        fout << pp.matrix_width; 
        fout << pp.H2_OUTPUT_LEN; 
        fout << pp.BATCH_SIZE; 

        fout << pp.npot_part;
        fout << pp.commonseed; 
    
        fout.close(); 
    }

    // load pp from file
    void FetchPP(PP &pp, std::string pp_filename)
    {
        std::ifstream fin; 
        fin.open(pp_filename, std::ios::binary); 
        if(!fin)
        {
            std::cerr << pp_filename << " open error" << std::endl;
            exit(1); 
        }

        fin >> pp.set_size; 
        fin >> pp.matrix_height; 
        fin >> pp.log_matrix_height; 
        fin >> pp.matrix_width; 
        fin >> pp.H2_OUTPUT_LEN; 
        fin >> pp.BATCH_SIZE; 

        fin >> pp.npot_part;
        fin >> pp.commonseed; 

        fin.close(); 
    }

    // hash each item in set to a 256-bits string (H1:{0,1}* -> {0,1}^256) and custom to 128-bits string [G(x_0) xor x_1] for the construction of PRF based on AES
    void HashInputSet(std::vector<block> &set, size_t set_size, std::vector<block> &hash_set, block aeskeysalt)
    {
        std::vector<std::vector<uint8_t>> hash_output(set_size, std::vector<uint8_t>(H1_OUTPUT_LEN));
        std::vector<block> temp_block(set_size);

        #pragma omp parallel for num_threads(thread_count)
		for (auto i = 0; i < set_size; i++) {
			BasicHash((uint8_t*)(set.data() + i), sizeof(block), hash_output[i].data());
			// H(x) = (x_0 || x_1)		
			temp_block[i] = *(block*)hash_output[i].data();
			set[i] = *(block*)(hash_output[i].data() + sizeof(block));
		}

        PRG::Seed seed = PRG::SetSeed(&aeskeysalt, 0); // the aeskeysalt is generated by PRG(commonseed)
        // compute [G(x_0)]
        AES::FastECBEnc(seed.aes_key, temp_block.data(), set_size);

        // compute [G(x_0) xor x_1]
        #pragma omp parallel for num_threads(thread_count)
        for (auto i = 0; i < set_size; i++)
        {
            hash_set[i] = temp_block[i] ^ set[i];
        }
    }

    // hash each item in matrix_mapping_values to a H2_OUTPUT_LEN string (H2:{0,1}^w -> {0,1}^{\ell2})
    std::vector<std::string> HashInputSet(PP &pp, std::vector<std::vector<uint8_t>> &matrix_mapping_values)
    {
        size_t matrix_width_byte = (pp.matrix_width + 7) >> 3;

		std::vector<std::vector<uint8_t>> matrix_input(pp.set_size, std::vector<uint8_t>(matrix_width_byte, 0));

        // convert the matrix_mapping_values[matrix_width][set_size_byte] to matrix_input[set_size][matrix_width_byte]
        #pragma omp parallel for num_threads(thread_count)
		for (auto low_index = 0; low_index < pp.set_size; low_index += pp.BATCH_SIZE)
		{
			for (auto i = 0; i < pp.matrix_width; i++)
			{
				for (auto j = low_index; j < low_index + pp.BATCH_SIZE; j++)
				{
					matrix_input[j][i >> 3] |= (uint8_t)((bool)(matrix_mapping_values[i][j >> 3] & (1 << (j & 7)))) << (i & 7);
				}
			}
		}

        uint8_t vec_hash_values[H1_OUTPUT_LEN];
        uint8_t split_hash_values[pp.H2_OUTPUT_LEN]; 
        std::vector<std::string> result(pp.set_size);

	    for (auto i = 0; i < pp.set_size; i++)
		{
            BasicHash(matrix_input[i].data(), matrix_width_byte, vec_hash_values);

            // convert the H1_OUTPUT_LEN uint8_t array to a H2_OUTPUT_LEN string 
            memcpy(split_hash_values, vec_hash_values, pp.H2_OUTPUT_LEN);
            result[i] = std::string((char*)(split_hash_values), pp.H2_OUTPUT_LEN);
		}

        return result;
    }

    // sender obtains a matrix with dimension n*w as the OPRF key
    std::vector<std::vector<uint8_t>> Send(NetIO &io, PP &pp)
    {
        /* step1: base OT (page 10 figure 4 item1)*/
        PRG::Seed seed = PRG::SetSeed(fix_key, 0);
		std::vector<uint8_t> vec_selection_bit = GenRandomBits(seed, pp.matrix_width); 

        std::vector<block> vec_K = NPOT::Receive(io, pp.npot_part, vec_selection_bit, pp.matrix_width);

        /* step2: compute matrix_C[matrix_width][matrix_height] (page 10 figure 4 item3)*/
        size_t log_height_byte = (pp.log_matrix_height + 7) >> 3; 
        size_t matrix_height_byte = pp.matrix_height >> 3;
        size_t split_bucket_size = sizeof(block) / log_height_byte; // the size of each splited part

        std::vector<std::vector<uint8_t>> matrix_C(pp.matrix_width, std::vector<uint8_t>(pp.matrix_height)); 

        PRG::Seed temp_seed[split_bucket_size];

        for (auto left_index = 0; left_index < pp.matrix_width; left_index += split_bucket_size)
        {
            auto right_index = left_index + split_bucket_size < pp.matrix_width ? left_index + split_bucket_size : pp.matrix_width;
            // bucket_size = split_bucket_size at most time, except for the last splited part
            auto bucket_size = right_index - left_index; 
			
            std::vector<uint8_t> rev_matrix_B(split_bucket_size * matrix_height_byte);
            io.ReceiveBytes(rev_matrix_B.data(), bucket_size * matrix_height_byte);

            #pragma omp parallel for num_threads(thread_count)
			for (auto i = 0; i < bucket_size; i++)
			{
                PRG::ReSeed(temp_seed[i], &vec_K[left_index + i], 0);
                matrix_C[left_index + i] = PRG::GenRandomBytes(temp_seed[i], matrix_height_byte);

				if (vec_selection_bit[left_index + i])
				{
                    #pragma omp parallel for num_threads(thread_count)
					for (auto j = 0; j < matrix_height_byte; j++)
					{
						matrix_C[left_index + i][j] ^= rev_matrix_B[i * matrix_height_byte + j];
					}
				}
			}
        }
        
        return matrix_C;
    }

    // sender evaluates OPRF values with input set use its own OPRF key
    std::vector<std::string> EvaluateOPRFValues(PP &pp, std::vector<std::vector<uint8_t>> &oprfkey, std::vector<block> &vec_X)
    {
        size_t set_size = vec_X.size();

        /* step1: hash each item x in vec_X to a 256-bits string and custom to a 128-bits string [G(x_0) xor x_1] */
        size_t log_height_byte = (pp.log_matrix_height + 7) >> 3;
        size_t split_bucket_size = sizeof(block) / log_height_byte;

        // AES_ENC_NUM = t + 1 (t in page 17)
        size_t AES_ENC_NUM = (pp.matrix_width / split_bucket_size) + 2;
        std::vector<block> aeskeys = PRG::GenRandomBlocks(pp.commonseed, AES_ENC_NUM); // AES keys used

        std::vector<block> hash_vec_X(set_size);
        HashInputSet(vec_X, set_size, hash_vec_X, aeskeys[0]);

        /* step2: compute matrix_location (computes v = F_k(H1(x)) in page 9 figure 3 item3-(b)) */
        size_t matrix_height_byte = pp.matrix_height >> 3;
        size_t MAX_LOCATION = (1 << pp.log_matrix_height) - 1;

        // the actual size is matrix_location[w][n*logn]
		std::vector<std::vector<uint8_t>> matrix_location(split_bucket_size, std::vector<uint8_t>(set_size * log_height_byte + sizeof(uint32_t)));
        std::vector<std::vector<uint8_t>> matrix_mapping_values(pp.matrix_width, std::vector<uint8_t>(matrix_height_byte, 0));

        PRG::Seed seed;

        // divides matrix_location into t parts from the matrix_width side
        for (auto left_index = 0; left_index < pp.matrix_width; left_index += split_bucket_size)
        {
            auto right_index = left_index + split_bucket_size < pp.matrix_width ? left_index + split_bucket_size : pp.matrix_width;
            auto bucket_size = right_index - left_index;

            PRG::ReSeed(seed, &aeskeys[left_index / split_bucket_size + 1], 0); 

            #pragma omp parallel for num_threads(thread_count)
            for (auto low_index = 0; low_index < set_size; low_index += pp.BATCH_SIZE)
			{
                // encrypt hash_vec_X t times, each time encrypt BATCH_SIZE blocks
                AES::FastECBEnc(seed.aes_key, hash_vec_X.data() + low_index, pp.BATCH_SIZE);
                
				for (auto i = 0; i < bucket_size; i++)
				{ // i is the index of bucket_size (matrix_width)
					for (auto j = low_index; j < low_index + pp.BATCH_SIZE; j++)
					{ // j is the index of set_size, but in the BATCH_SIZE way 
                        //when j = 0, the left log_height_byte columns of matrix_location is the result of F_k(H(x1)) 
						memcpy(matrix_location[i].data() + j * log_height_byte, (uint8_t*)(hash_vec_X.data() + j) + i * log_height_byte, log_height_byte); 
                    }
				}
			}

            // compute mapping values from the oprfkey (compute (C1[v[1]] || ... || Cw[v[w]]) in page 9 figure 3 item3-(b))
            #pragma omp parallel for num_threads(thread_count)
            for (auto i = 0; i < bucket_size; i++)
			{
				for (auto j = 0; j < set_size; j++)
				{
                    auto location = (*(uint32_t*)(matrix_location[i].data() + j * log_height_byte)) & MAX_LOCATION;
					matrix_mapping_values[left_index + i][j >> 3] |= (uint8_t)((bool)(oprfkey[left_index + i][location >> 3] & (1 << (location & 7)))) << (j & 7);
				}
			}
        }

        // compute \Psi = H2(C1[v[1]] || ... || Cw[v[w]])
        std::vector<std::string> vec_oprf_values = HashInputSet(pp, matrix_mapping_values);

        return vec_oprf_values;
    }

    // receiver obtains OPRF values with input set
    std::vector<std::string> Receive(NetIO &io, PP &pp, std::vector<block> &vec_Y)
    {
        size_t set_size = vec_Y.size();

        /* step1: base OT (page 10 figure 4 item1) */
        PRG::Seed seed = PRG::SetSeed(fix_key, 0); 
        std::vector<block> vec_K0 = PRG::GenRandomBlocks(seed, pp.matrix_width);
        std::vector<block> vec_K1 = PRG::GenRandomBlocks(seed, pp.matrix_width);

		NPOT::Send(io, pp.npot_part, vec_K0, vec_K1, pp.matrix_width);

        /* step2: hash each item y in vec_Y to a 256-bits string and custom to a 128-bits string [G(y_0) xor y_1] */
        size_t log_height_byte = (pp.log_matrix_height + 7) >> 3; 
        size_t split_bucket_size = sizeof(block) / log_height_byte;

        // AES_ENC_NUM = t + 1 (t in page 17)
        size_t AES_ENC_NUM = (pp.matrix_width / split_bucket_size) + 2;
        std::vector<block> aeskeys = PRG::GenRandomBlocks(pp.commonseed, AES_ENC_NUM); // AES keys used

        std::vector<block> hash_vec_Y(set_size);
        HashInputSet(vec_Y, set_size, hash_vec_Y, aeskeys[0]);

        /* 
        ** (page 10 figure 4 item2)
        ** step3: compute matrix_location[w][n*logn] = {F_k(H(y_i))} and matrix A, B, D in parallel; 
        ** F: {0,1}^{128} * {0,1}^{128} -> {0,1}^{w*logn} is implemented by applying AES ENC t times, t = ceil(w*logn/128);
        ** F_k(y) = G_k1(G_k0(y0) xor y1) || ... || G_kt(G_k0(y0) xor y1), PRG(k) -> k0 || k1 || ... || kt
        ** matrix A, B, D, location are divided into t parts from the matrix_width side;
        */
        size_t matrix_height_byte = pp.matrix_height >> 3;
        size_t MAX_LOCATION = (1 << pp.log_matrix_height) - 1; 

        // the actual size is matrix_A[w][n]
        std::vector<std::vector<uint8_t>> matrix_A(split_bucket_size, std::vector<uint8_t>(matrix_height_byte));
		std::vector<std::vector<uint8_t>> matrix_D(split_bucket_size, std::vector<uint8_t>(matrix_height_byte));
        // the actual size is matrix_location[w][n*logn]
		std::vector<std::vector<uint8_t>> matrix_location(split_bucket_size, std::vector<uint8_t>(set_size * log_height_byte + sizeof(uint32_t)));
        std::vector<std::vector<uint8_t>> matrix_mapping_values(pp.matrix_width, std::vector<uint8_t>(matrix_height_byte, 0));
 
        // divides into t parts
        for (auto left_index = 0; left_index < pp.matrix_width; left_index += split_bucket_size)
        {
            auto right_index = left_index + split_bucket_size < pp.matrix_width ? left_index + split_bucket_size : pp.matrix_width;
            auto bucket_size = right_index - left_index;

            PRG::ReSeed(seed, &aeskeys[left_index / split_bucket_size + 1], 0); 

            /* step3-1: compute matrix_location (computes v = F_k(H1(y)) in page 9 figure 3 item3-(c)) */
            #pragma omp parallel for num_threads(thread_count)
            for (auto low_index = 0; low_index < set_size; low_index += pp.BATCH_SIZE)
			{
                // encrypt hash_vec_Y t times, each time encrypt BATCH_SIZE blocks
                AES::FastECBEnc(seed.aes_key, hash_vec_Y.data() + low_index, pp.BATCH_SIZE);

				for (auto i = 0; i < bucket_size; i++)
				{ // i is the index of bucket_size (matrix_width)
					for (auto j = low_index; j < low_index + pp.BATCH_SIZE; j++)
					{ // j is the index of set_size, , but in the BATCH_SIZE way 
                        //when j = 0, the left log_height_byte columns of matrix_location is the result of F_k(H(y1)) 
						memcpy(matrix_location[i].data() + j * log_height_byte, (uint8_t*)(hash_vec_Y.data() + j) + i * log_height_byte, log_height_byte); 
                    }
				}
			}

            // initialize a all one matrix_D
            #pragma omp parallel for num_threads(thread_count)
            for (auto i = 0; i < split_bucket_size; i++)
			{
				memset(matrix_D[i].data(), 255, matrix_height_byte);
			}

            /* step3-2: compute matrix_D (page 9 figure 3 item1-(c)) */
            #pragma omp parallel for num_threads(thread_count)
			for (auto i = 0; i < bucket_size; i++)
			{
				for (auto j = 0; j < set_size; j++)
				{
                    // get a location from matrix_location, and set the value of that location in matrix_D to 0
					auto location_in_D = (*(uint32_t*)(matrix_location[i].data() + j * log_height_byte)) & MAX_LOCATION;
					matrix_D[i][location_in_D >> 3] &= ~(1 << (location_in_D & 7));
				}
			}

            /* step3-3: compute matrix_B and send to sender (page 10 figure 4 item2) */
            std::vector<std::vector<uint8_t>> matrix_B(bucket_size, std::vector<uint8_t>(matrix_height_byte));
            std::vector<uint8_t> send_matrix_B(bucket_size * matrix_height_byte);
            PRG::Seed temp_seed[bucket_size];

            #pragma omp parallel for num_threads(thread_count)
			for (auto i = 0; i < bucket_size; i++)
			{
                PRG::ReSeed(temp_seed[i], &vec_K0[left_index + i], 0);
                matrix_A[i] = PRG::GenRandomBytes(temp_seed[i], matrix_height_byte);

                PRG::ReSeed(temp_seed[i], &vec_K1[left_index + i], 0);
                matrix_B[i] = PRG::GenRandomBytes(temp_seed[i], matrix_height_byte);

                #pragma omp parallel for num_threads(thread_count)
				for (auto j = 0; j < matrix_height_byte; j++)
				{
					matrix_B[i][j] ^= matrix_A[i][j] ^ matrix_D[i][j];
                    send_matrix_B[i * matrix_height_byte + j] = matrix_B[i][j];
				}
			}
            io.SendBytes(send_matrix_B.data(), bucket_size * matrix_height_byte);
            
            /* step3-4: compute mapping values from matrix A (compute (A1[v[1]] || ... || Aw[v[w]]) in page 9 figure 3 item3-(c)) */ 
            #pragma omp parallel for num_threads(thread_count)
            for (auto i = 0; i < bucket_size; i++)
			{
				for (auto j = 0; j < set_size; j++)
				{
                    auto location_in_A = (*(uint32_t*)(matrix_location[i].data() + j * log_height_byte)) & MAX_LOCATION;
					matrix_mapping_values[left_index + i][j >> 3] |= (uint8_t)((bool)(matrix_A[i][location_in_A >> 3] & (1 << (location_in_A & 7)))) << (j & 7);
				}
			}

        }

        PrintSplitLine('-');
        std::cout << "multi-point OPRF: Receiver ===> matrix_B ===> Sender [" << (double)(pp.matrix_width * matrix_height_byte)/(1 << 20) << " MB]" << std::endl;

        // compute \Psi = H2(A1[v[1]] || ... || Aw[v[w]])
        std::vector<std::string> vec_oprf_values = HashInputSet(pp, matrix_mapping_values);

        return vec_oprf_values;
    }

}

#endif