// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RECEIVERDB_APSU_FBS_H_
#define FLATBUFFERS_GENERATED_RECEIVERDB_APSU_FBS_H_

#include "flatbuffers/flatbuffers.h"

#include "apsu/psu_params_generated.h"

namespace apsu {
namespace fbs {

struct HashedItem;

struct ReceiverDBInfo;

struct ReceiverDB;
struct ReceiverDBBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) HashedItem FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t low_word_;
  uint64_t high_word_;

 public:
  HashedItem()
      : low_word_(0),
        high_word_(0) {
  }
  HashedItem(uint64_t _low_word, uint64_t _high_word)
      : low_word_(flatbuffers::EndianScalar(_low_word)),
        high_word_(flatbuffers::EndianScalar(_high_word)) {
  }
  uint64_t low_word() const {
    return flatbuffers::EndianScalar(low_word_);
  }
  uint64_t high_word() const {
    return flatbuffers::EndianScalar(high_word_);
  }
};
FLATBUFFERS_STRUCT_END(HashedItem, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ReceiverDBInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t label_byte_count_;
  uint32_t nonce_byte_count_;
  uint64_t item_count_;
  uint8_t compressed_;
  uint8_t stripped_;
  int16_t padding0__;  int32_t padding1__;

 public:
  ReceiverDBInfo()
      : label_byte_count_(0),
        nonce_byte_count_(0),
        item_count_(0),
        compressed_(0),
        stripped_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  ReceiverDBInfo(uint32_t _label_byte_count, uint32_t _nonce_byte_count, uint64_t _item_count, bool _compressed, bool _stripped)
      : label_byte_count_(flatbuffers::EndianScalar(_label_byte_count)),
        nonce_byte_count_(flatbuffers::EndianScalar(_nonce_byte_count)),
        item_count_(flatbuffers::EndianScalar(_item_count)),
        compressed_(flatbuffers::EndianScalar(static_cast<uint8_t>(_compressed))),
        stripped_(flatbuffers::EndianScalar(static_cast<uint8_t>(_stripped))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  uint32_t label_byte_count() const {
    return flatbuffers::EndianScalar(label_byte_count_);
  }
  uint32_t nonce_byte_count() const {
    return flatbuffers::EndianScalar(nonce_byte_count_);
  }
  uint64_t item_count() const {
    return flatbuffers::EndianScalar(item_count_);
  }
  bool compressed() const {
    return flatbuffers::EndianScalar(compressed_) != 0;
  }
  bool stripped() const {
    return flatbuffers::EndianScalar(stripped_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(ReceiverDBInfo, 24);

struct ReceiverDB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReceiverDBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMS = 4,
    VT_INFO = 6,
    VT_OPRF_KEY = 8,
    VT_HASHED_ITEMS = 10,
    VT_BIN_BUNDLE_COUNT = 12
  };
  const flatbuffers::Vector<uint8_t> *params() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PARAMS);
  }
  const apsu::fbs::ReceiverDBInfo *info() const {
    return GetStruct<const apsu::fbs::ReceiverDBInfo *>(VT_INFO);
  }
  const flatbuffers::Vector<uint8_t> *oprf_key() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OPRF_KEY);
  }
  const flatbuffers::Vector<const apsu::fbs::HashedItem *> *hashed_items() const {
    return GetPointer<const flatbuffers::Vector<const apsu::fbs::HashedItem *> *>(VT_HASHED_ITEMS);
  }
  uint32_t bin_bundle_count() const {
    return GetField<uint32_t>(VT_BIN_BUNDLE_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           VerifyField<apsu::fbs::ReceiverDBInfo>(verifier, VT_INFO, 8) &&
           VerifyOffsetRequired(verifier, VT_OPRF_KEY) &&
           verifier.VerifyVector(oprf_key()) &&
           VerifyOffsetRequired(verifier, VT_HASHED_ITEMS) &&
           verifier.VerifyVector(hashed_items()) &&
           VerifyField<uint32_t>(verifier, VT_BIN_BUNDLE_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct ReceiverDBBuilder {
  typedef ReceiverDB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_params(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> params) {
    fbb_.AddOffset(ReceiverDB::VT_PARAMS, params);
  }
  void add_info(const apsu::fbs::ReceiverDBInfo *info) {
    fbb_.AddStruct(ReceiverDB::VT_INFO, info);
  }
  void add_oprf_key(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> oprf_key) {
    fbb_.AddOffset(ReceiverDB::VT_OPRF_KEY, oprf_key);
  }
  void add_hashed_items(flatbuffers::Offset<flatbuffers::Vector<const apsu::fbs::HashedItem *>> hashed_items) {
    fbb_.AddOffset(ReceiverDB::VT_HASHED_ITEMS, hashed_items);
  }
  void add_bin_bundle_count(uint32_t bin_bundle_count) {
    fbb_.AddElement<uint32_t>(ReceiverDB::VT_BIN_BUNDLE_COUNT, bin_bundle_count, 0);
  }
  explicit ReceiverDBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReceiverDB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReceiverDB>(end);
    fbb_.Required(o, ReceiverDB::VT_PARAMS);
    fbb_.Required(o, ReceiverDB::VT_OPRF_KEY);
    fbb_.Required(o, ReceiverDB::VT_HASHED_ITEMS);
    return o;
  }
};

inline flatbuffers::Offset<ReceiverDB> CreateReceiverDB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> params = 0,
    const apsu::fbs::ReceiverDBInfo *info = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> oprf_key = 0,
    flatbuffers::Offset<flatbuffers::Vector<const apsu::fbs::HashedItem *>> hashed_items = 0,
    uint32_t bin_bundle_count = 0) {
  ReceiverDBBuilder builder_(_fbb);
  builder_.add_bin_bundle_count(bin_bundle_count);
  builder_.add_hashed_items(hashed_items);
  builder_.add_oprf_key(oprf_key);
  builder_.add_info(info);
  builder_.add_params(params);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReceiverDB> CreateReceiverDBDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *params = nullptr,
    const apsu::fbs::ReceiverDBInfo *info = nullptr,
    const std::vector<uint8_t> *oprf_key = nullptr,
    const std::vector<apsu::fbs::HashedItem> *hashed_items = nullptr,
    uint32_t bin_bundle_count = 0) {
  auto params__ = params ? _fbb.CreateVector<uint8_t>(*params) : 0;
  auto oprf_key__ = oprf_key ? _fbb.CreateVector<uint8_t>(*oprf_key) : 0;
  auto hashed_items__ = hashed_items ? _fbb.CreateVectorOfStructs<apsu::fbs::HashedItem>(*hashed_items) : 0;
  return apsu::fbs::CreateReceiverDB(
      _fbb,
      params__,
      info,
      oprf_key__,
      hashed_items__,
      bin_bundle_count);
}

inline const apsu::fbs::ReceiverDB *GetReceiverDB(const void *buf) {
  return flatbuffers::GetRoot<apsu::fbs::ReceiverDB>(buf);
}

inline const apsu::fbs::ReceiverDB *GetSizePrefixedReceiverDB(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<apsu::fbs::ReceiverDB>(buf);
}

inline bool VerifyReceiverDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<apsu::fbs::ReceiverDB>(nullptr);
}

inline bool VerifySizePrefixedReceiverDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<apsu::fbs::ReceiverDB>(nullptr);
}

inline void FinishReceiverDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<apsu::fbs::ReceiverDB> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedReceiverDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<apsu::fbs::ReceiverDB> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace apsu

#endif  // FLATBUFFERS_GENERATED_RECEIVERDB_APSU_FBS_H_
